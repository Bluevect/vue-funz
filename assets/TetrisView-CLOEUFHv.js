import{q as T,c as y,d as V,u as q,a as K,b as D,r as G,e as x,s as j,o as F,g as O,h as i,i as _,t as u,j as P,k as C,l as N,_ as J}from"./index-0W-_GK_W.js";const d=T({bg:"gray",blockColor:"#304c9a",nextShapeColor:"orange",gameOverColor:"red",time:200}),c=T({width:10,height:20,blockWidth:30,blockHeight:30}),v=T({width:4,height:4,blockWidth:25,blockHeight:25}),E=y(()=>c.width*c.height),$=y(()=>v.width*v.height);function m(l,t,e,n=c){const{width:r,blockWidth:s,blockHeight:a}=n;e.fillStyle=t;const h=l%r*s,S=Math.floor(l/r)*a;e.fillRect(h+1,S+1,s-1,a-1)}function k(l,t,e=c,n=E.value){for(let r=0;r<n;r++)m(r,l,t,e)}const I=[{name:"I",shape:[0,1,2,3]},{name:"J",shape:[0,4,5,6]},{name:"L",shape:[2,4,5,6]},{name:"O",shape:[0,1,4,5]},{name:"S",shape:[1,2,4,5]},{name:"T",shape:[1,4,5,6]},{name:"Z",shape:[0,1,5,6]}],U=[12,8,4,0,13,9,5,1,14,10,6,2,15,11,7,3];let W=()=>{},A=()=>{},L=()=>{};function Z(l){A=l}function z(l){W=l}function Q(l){L=l}class X{interval=0;cxt;nextCxt;currentShapePreset=[];currentShapePos=0;currentShape=[];nextShape=[];blocksPos=[];constructor(t,e){this.cxt=t,this.nextCxt=e}generateNextShape(){const t=Math.floor(Math.random()*I.length);return I[t].shape}drawNextShape(t){t.forEach(e=>{m(e,d.nextShapeColor,this.nextCxt,v)})}drawNextShapeOnMap(t){t.forEach(e=>{m(e,d.blockColor,this.cxt)})}move(t){const{bg:e,blockColor:n}=d,{width:r}=c;let s=!0;return this.currentShape.forEach(a=>{const h=a+t;(h>=E.value||this.blocksPos.includes(h)||h%r==0&&t==1||(h+1)%r==0&&t==-1)&&(s=!1)}),s?(this.currentShape.forEach(a=>{m(a,e,this.cxt)}),this.currentShape=this.currentShape.map(a=>a+t),this.currentShapePos+=t,this.currentShape.forEach(a=>{m(a,n,this.cxt)}),1):0}rotate(){const{bg:t,blockColor:e}=d,n=this.currentShapePreset.map(s=>U[s]),r=n.map(s=>this.toMapPos(s)+this.currentShapePos);r.some(s=>s>=E.value||s<0||this.blocksPos.includes(s))||(this.currentShape.forEach(s=>{m(s,t,this.cxt)}),this.currentShapePreset=n,this.currentShape=r,this.currentShape.forEach(s=>{m(s,e,this.cxt)}))}toMapPos(t){const{width:e}=c,{width:n}=v;return t%n+Math.floor(t/n)*e}eliminate(){const{width:t}=c,{bg:e,blockColor:n}=d;let r=0,s=-1;const a=[];this.blocksPos.sort((h,S)=>h-S),this.blocksPos.forEach(h=>{s>=0&&Math.floor(h/t)!=Math.floor(s/t)&&(r=0),r++,r==t&&(r=0,a.push(Math.floor(h/t))),s=h}),a.length>0&&A(a.length),a.forEach(h=>{for(let p=0;p<t;p++)m(h*t+p,e,this.cxt);const S=this.blocksPos.indexOf(h*t);this.blocksPos.splice(S,t);for(let p=S-1;p>=0;p--)m(this.blocksPos[p],e,this.cxt),this.blocksPos[p]+=t,m(this.blocksPos[p],n,this.cxt)})}start(){const{width:t}=c;W(),this.currentShapePreset=this.generateNextShape(),this.currentShape=this.currentShapePreset.map(e=>this.toMapPos(e)),this.drawNextShapeOnMap(this.currentShape),this.nextShape=this.generateNextShape(),this.drawNextShape(this.nextShape),this.interval=setInterval(()=>{this.move(t)==0&&(this.currentShape.some(n=>n<c.width)&&this.gameOver(),this.drawNextShapeOnMap(this.currentShape),this.blocksPos.push(...this.currentShape),this.eliminate(),this.currentShapePos=0,this.currentShapePreset=this.nextShape,this.currentShape=this.currentShapePreset.map(n=>this.toMapPos(n)),this.nextShape=this.generateNextShape(),k(d.bg,this.nextCxt,v,$.value),this.drawNextShape(this.nextShape))},d.time)}gameOver(){clearInterval(this.interval),this.blocksPos=[],L()}}const Y={class:"canvas-container"},tt=["width","height"],et={class:"next-shape-container"},st={key:0,class:"menu"},at={key:1,class:"game-over"},rt={class:"menu"},nt=V({__name:"TetrisView",setup(l){const t=q(),e=D(),n=K();e.query.hasOwnProperty("lang")?(t.update(e.query.lang),n.locale.value=t.lang):G.push({path:"/snake",query:{lang:t.lang}});const r=x(null),s=x(null),a=x(0),h=x(!0),S=x(!1),p=j(),B=y(()=>c.width*c.blockWidth+1),H=y(()=>c.height*c.blockHeight+1);let f,b=null,w=null;Z(o=>{switch(o){case 1:a.value+=1;break;case 2:a.value+=3;break;case 3:a.value+=5;break;case 4:a.value+=8;break}}),z(()=>{a.value=0,S.value=!1,h.value=!1,k(d.bg,b),k(d.bg,w,v,$.value),window.onkeydown=o=>{switch(o.code){case"KeyW":case"ArrowUp":f.rotate();break;case"KeyS":case"ArrowDown":f.move(c.width);break;case"KeyA":case"ArrowLeft":f.move(-1);break;case"KeyD":case"ArrowRight":f.move(1);break}}}),Q(()=>{window.onkeydown=R,S.value=!0,p.update(a.value)}),F(()=>{const o=r.value,g=s.value;if(b=o.getContext("2d"),w=g.getContext("2d"),!b||!w)throw new Error("Failed to get canvas context");k(d.bg,b),k(d.bg,w,v,$.value),f=new X(b,w),window.onkeydown=R});function R(o){o.code=="Space"&&f.start()}return(o,g)=>(N(),O("div",Y,[i("canvas",{ref_key:"mapRef",ref:r,width:B.value,height:H.value},null,8,tt),i("div",et,[i("h3",null,u(o.$t("tetris.score"))+" "+u(a.value),1),g[2]||(g[2]=i("br",null,null,-1)),i("h3",null,u(o.$t("tetris.nextShape")),1),i("canvas",{ref_key:"nextShapeRef",ref:s,width:"101",height:"101"},null,512)]),h.value?(N(),O("h2",st,[P(u(o.$t("tetris.press"))+" ",1),i("i",null,u(o.$t("tetris.space")),1),P(" "+u(o.$t("tetris.menuStart"))+" ",1),i("button",{class:"start-btn",onClick:g[0]||(g[0]=(...M)=>C(f).start&&C(f).start(...M))},u(o.$t("tetris.startBtn")),1)])):_("",!0),S.value?(N(),O("div",at,[i("div",null,[i("span",null,u(o.$t("tetris.gameOverTitle")),1),g[3]||(g[3]=i("br",null,null,-1)),i("h2",rt,[P(u(o.$t("tetris.press"))+" ",1),i("i",null,u(o.$t("tetris.space")),1),P(" "+u(o.$t("tetris.menuRestart"))+" ",1),i("button",{class:"restart-btn",onClick:g[1]||(g[1]=(...M)=>C(f).start&&C(f).start(...M))},u(o.$t("tetris.restartBtn")),1)])])])):_("",!0)]))}}),ht=J(nt,[["__scopeId","data-v-a093d3e1"]]);export{ht as default};
